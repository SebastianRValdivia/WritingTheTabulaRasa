<template>
  <q-page class="q-pl-md">
    <div class="row q-pa-md float-right">

      <q-input 
        rounded
        outlined
        v-model="searchInput"
        class="col col-12"
      >
        <template v-slot:append>
          <q-icon name="search" />
        </template>
      </q-input>
      <q-toggle
        class="col col-12"
        v-model="showCompleted"
        checked-icon="check"
        unchecked-icon="clear"
        color="info"
        :label="$t('taskListPage.showCompleted')"
      />
    </div>

    <div class="row q-gutter-sm">
      <q-input v-model="newTaskInput.titleInput" class="col-7">
        <template v-slot:prepend>
          <q-icon name="alt_route" size="sm" class="q-pa-sm">
            <q-popup-edit v-model="newTaskInput.requireInput" v-slot="scope">
              <q-input 
                v-model="scope.value"
                dense 
                type="number"
                autofocus 
                @keyup.enter="scope.set" 
                style="max-width: 8rem;"
              >
                <template v-slot:prepend>
                  <span class="text-caption">ID: </span>
                </template>
              </q-input>

            </q-popup-edit>
          </q-icon>
          <span class="q-pa-sm" v-if="newTaskInput.requireInput !== null">{{ newTaskInput.requireInput }}</span>
        </template>
      </q-input>
      <q-btn flat rounded @click="addNewTask" icon="add" size="md"/>
    </div>

    <q-list padding separator class="row ">
      <q-item class="col-7" v-for="task in displayedTasks" :key="task.id">
        <q-item-section>
          <q-item-label> 
            <q-checkbox 
              v-model="task.completed" 
              :disable="!requiredCompleted(task)"
              @click="toggleStatus(task.id)"
              class="secondary"
            />
            {{ task.title }}
          </q-item-label>
        </q-item-section>
        <q-item-section avatar>
          ID: {{ task.id }}
        </q-item-section>
        <q-item-section avatar>
          <q-btn 
            flat 
            round 
            color="negative" 
            icon="delete" 
            @click="deleteTask(task.id)"
          />
        </q-item-section>
      </q-item>
    </q-list>
  </q-page>
</template>

<script>
import { ref, reactive, computed, onBeforeMount } from "vue"
import { useQuasar } from "quasar"
import { useI18n } from "vue-i18n"
import Fuse from "fuse.js"

import { useTaskStore } from "src/stores/task-store"
import { useUserStore } from "src/stores/user-store"

export default {
  setup() {
    const taskStore = useTaskStore()
    const userStore = useUserStore()
    const $q = useQuasar()
    const { t } = useI18n()

    const newTaskInput = reactive({
      titleInput: "",
      requireInput: null,
    })
    const showCompleted = ref(false)
    const searchInput = ref("")

    const displayedTasks = computed(() => {
      let toDisplay = []
      if (showCompleted.value) {
        if (searchInput.value) {
          let searchResults = searchTask(
            taskStore.getTaskByUser(userStore.getUserId),
            searchInput.value
          )
          searchResults.forEach((item) => toDisplay.push(item.item)) // To remove "item" key generated by fuse
        } else {
          toDisplay = taskStore.getTaskByUser(userStore.getUserId)
        }
      } else {
        if (searchInput.value) {
          let searchResults = searchTask(
            taskStore.getTaskByUser(userStore.getUserId),
            searchInput.value
          )
          searchResults.forEach((item) => toDisplay.push(item.item))
          toDisplay = toDisplay.filter((task => task.completed === false))
        } else {
          toDisplay = taskStore.getTaskByUser(userStore.getUserId)
            .filter((task => task.completed === false))
        }
      }
      return toDisplay
    })

    function requiredCompleted(task) {
      if (task.require === null) {
        return true
      } else {
        let requiredTask = taskStore.getTaskById(task.require)
        if (requiredTask.completed === true) {
          return true
        } else {
          return false
        } 
      }
    }
    async function toggleStatus(taskId) {
      let task = taskStore.getTaskById(taskId)
      if (task.require === null) {
        await taskStore.changeTaskStatus({
          taskId: taskId,
          newStatus: task.completed // The new status is already inverted due to the v-model in the checkbox
        })
      } else {
        $q.notify({
          message: t("taskListPage.requiredIncomplete"),
          color: "negative"
        })
      }
    }
    async function addNewTask() {
      if (newTaskInput.requireInput === null || taskStore.getTaskById(Number(newTaskInput.requireInput)) !== undefined) {
        await taskStore.addNewTask({
            title: newTaskInput.titleInput,
            require: newTaskInput.requireInput,
          })
      } else {
        $q.notify({
          message: t("taskListPage.requiredWrong"),
          color: "negative"
        })
      }

    }
    async function deleteTask(taskId) {
      $q.dialog({
        title: t("taskListPage.deleteTask"),
        message: t("taskListPage.deleteTaskTip")
      }).onOk(async () => {
        await taskStore.removeTask({taskId: taskId})
        $q.notify({
          message: t("taskListPage.taskDeleted"),
          color: "positive"
        })
      })
    }

    function searchTask(list, searchPattern) {
      let fuzzySearch = new Fuse(
        list,
        { // Options
          keys: [
            "title"
          ]
        }
      )
      return fuzzySearch.search(searchPattern)
    }

    onBeforeMount(async () => {
      $q.loading.show()
      await taskStore.retrieveTasks()
      $q.loading.hide()
    })

    return {
      displayedTasks,
      taskStore,
      newTaskInput,
      addNewTask,
      toggleStatus,
      showCompleted,
      deleteTask,
      requiredCompleted,
      searchInput,
    }
  }
}
</script>
